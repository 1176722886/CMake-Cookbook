# 5.2 配置时运行自定义命令

**NOTE**:*此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02 中找到。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。*

运行CMake生成构建系统，从而指定原生构建工具必须执行哪些命令，以及按照什么顺序执行。我们已经了解了CMake如何在配置时运行许多子任务，以便找到工作的编译器和必要的依赖项。本示例中，我们将讨论如何使用`execute_process`命令在配置时运行定制化命令。

## 具体实施

第3章第3节中，我们已经展示了`execute_process`在尝试查找Python模块NumPy时的用法。本例中，我们将使用`execute_process`命令来确定是否存在特定的Python模块(本例中为Python CFFI)，如果存在，我们将确定版本:

1. 对于这个简单的例子，不需要语言支持:

   ```cmake
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
   project(recipe-02 LANGUAGES NONE)
   ```

2. 我们要求Python解释器执行一个简短的代码片段，因此，我们需要使用`find_package`来查找解释器：

   ```cmake
   find_package(PythonInterp REQUIRED)
   ```

3. 然后调用`execute_process`来运行一个简短的Python代码段；下一节中，我们将更详细地讨论这个命令:

   ```cmake
   # this is set as variable to prepare
   # for abstraction using loops or functions
   set(_module_name "cffi")
   
   execute_process(
     COMMAND
     	${PYTHON_EXECUTABLE} "-c" "import ${_module_name}; print(${_module_name}.__version__)"
     OUTPUT_VARIABLE _stdout
     ERROR_VARIABLE _stderr
     OUTPUT_STRIP_TRAILING_WHITESPACE
     ERROR_STRIP_TRAILING_WHITESPACE
     )
   ```

4. 然后，我们打印结果：

   ```cmake
   if(_stderr MATCHES "ModuleNotFoundError")
   	message(STATUS "Module ${_module_name} not found")
   else()
   	message(STATUS "Found module ${_module_name} v${_stdout}")
   endif()
   ```

5. 下面是一个配置示例(假设Python CFFI包安装在相应的Python环境中):

   ```shell
   $ mkdir -p build
   $ cd build
   $ cmake ..
   
   -- Found PythonInterp: /home/user/cmake-cookbook/chapter-05/recipe-02/example/venv/bin/python (found version "3.6.5")
   -- Found module cffi v1.11.5
   ```

## 更多信息

本例中，我们只打印了结果，但实际项目中，我们可以警告、中止配置，或者设置可以查询的变量，来切换某些配置选项。

代码示例会扩展到多个Python模块(如Cython)，以避免代码重复。一种选择是使用`foreach`循环模块名，另一种方法是将代码封装为函数或宏。我们将在第7章中讨论这些封装。

第9章中，我们将使用Python CFFI和Cython，现在的示例可以作为有用的、可重用的代码片段，来检测这些包是否存在。

