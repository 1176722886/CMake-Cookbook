# 3.5 检测OpenMP的并行环境

**NOTE**:*此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05 中找到，有C++和Fortran示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05 中也有一个适用于CMake 3.5的示例。*

目前，市面上的计算机几乎都是多核机器，对于性能敏感的程序，我们必须关注这些多核处理器，并在编程模型中使用并发。OpenMP是多核处理器上并行性的标准之一。为了从OpenMP并行化中获得性能收益，通常不需要修改或重写现有程序。一旦确定了代码中的性能关键部分，例如：使用分析工具，程序员就可以通过预处理器指令，指示编译器为这些区域生成可并行的代码。

在本示例中，我们将展示如何编译一个包含OpenMP指令的程序(前提是使用一个支持OpenMP的编译器)。有许多支持OpenMP的Fortran、C和C++编译器。对于相对较新的CMake版本，为OpenMP提供了非常好的支持。本示例将向展示如何在使用CMake 3.9或更高版本时，使用简单C++和Fortran程序来检测，并链接到OpenMP。

**NOTE**:*根据Linux发行版的不同，Clang编译器的默认版本可能不支持OpenMP。使用或非苹果版本的Clang(例如，Conda提供的)或GNU编译器,除非单独安装libomp库(https://iscinumpy.gitlab.io/post/omp-on-high-sierra/ )，否则本节示例将无法在macOS上工作。*

## 具体实施

对于C++和Fortran的例子，`CMakeLists.txt`将遵循一个模板，该模板在这两种语言上很相似：

1. 两者都定义了一个最低CMake版本、项目名称和语言(CXX或Fortran；我们将展示C++版本):

   ```cmake
   cmake_minimum_required(VERSION 3.9 FATAL_ERROR)
   project(recipe-05 LANGUAGES CXX)
   ```

2. 使用C++11标准:

   ```cmake
   set(CMAKE_CXX_STANDARD 11)
   set(CMAKE_CXX_EXTENSIONS OFF)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   ```

3. 调用find_package来搜索OpenMP:

   ```cmake
   find_package(OpenMP REQUIRED)
   ```

4. 最后，我们定义可执行目标，并链接到FindOpenMP模块提供的导入目标(在Fortran的情况下，我们链接到`OpenMP::OpenMP_Fortran`):

   ```cmake
   add_executable(example example.cpp)
   target_link_libraries(example
     PUBLIC
     	OpenMP::OpenMP_CXX
     )
   ```

5. 现在，可以配置和构建代码了:

   ```shell
   $ mkdir -p build
   $ cd build
   $ cmake ..
   $ cmake --build .
   ```

6. 并行测试(在本例中使用了4个内核):

   ```shell
   $ ./example 1000000000
   
   number of available processors: 4
   number of threads: 4
   we will form sum of numbers from 1 to 1000000000
   sum: 500000000500000000
   elapsed wall clock time: 1.08343 seconds
   ```

7. 为了比较，我们可以重新运行这个例子，并将OpenMP线程的数量设置为1:

   ```shell
   $ env OMP_NUM_THREADS=1 ./example 1000000000
   
   number of available processors: 4
   number of threads: 1
   we will form sum of numbers from 1 to 1000000000
   sum: 500000000500000000
   elapsed wall clock time: 2.96427 seconds
   ```

## 如何工作

我们的示例很简单：编译并链接的代码，运行在多个内核上时，我们会看到加速效果。加速效果并不是`OMP_NUM_THREADS`的倍数，不过本示例中并不关心，因为我们更关注的是如何使用CMake配置需要使用OpenMP的项目。我们发现链接到OpenMP非常简单，这要感谢`FindOpenMP`模块提供的目标:

```cmake
target_link_libraries(example
	PUBLIC
		OpenMP::OpenMP_CXX
	)
```

我们不关心编译标志或包含目录——这些设置和依赖项是在`OpenMP::OpenMP_CXX`的定义中已定义的，是`IMPORTED`类型。如第1章第3节中提到的，`IMPORTED`库是伪目标，它完全是我们自己项目的外部依赖项。要使用OpenMP，需要设置一些编译器标志，包括目录和链接库。所有这些都包含在`OpenMP::OpenMP_CXX`的属性上，并通过使用`target_link_libraries`命令传递到我们的`example`目标。这使得在CMake中，使用库变得非常容易。我们可以使用`cmake_print_properties`命令打印接口的属性，该命令由`CMakePrintHelpers.CMake`模块提供:

```cmake
include(CMakePrintHelpers)
cmake_print_properties(
	TARGETS
		OpenMP::OpenMP_CXX
	PROPERTIES
		INTERFACE_COMPILE_OPTIONS
		INTERFACE_INCLUDE_DIRECTORIES
		INTERFACE_LINK_LIBRARIES
	)
```

所有属性都有`INTERFACE_`前缀，因为这些属性对所需目标，需要是以接口形式提供，并且目标以接口的方式使用OpenMP。

对于低于3.9的CMake版本，我们有更多的工作量:

```cmake
add_executable(example example.cpp)

target_compile_options(example
  PUBLIC
  	${OpenMP_CXX_FLAGS}
  )
  
set_target_properties(example
  PROPERTIES
  	LINK_FLAGS ${OpenMP_CXX_FLAGS}
  )
```

对于低于3.5的CMake版本，我们需要为Fortran项目显式定义编译标志。

在这个示例中，我们讨论了C++和Fortran，相同的参数和方法对于C项目也有效。