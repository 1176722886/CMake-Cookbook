# 9.2 使用Fortran库构建C/C++项目

**NOTE**:*此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-02 中找到，其中有一个示例：一个是C++、C和Fortran的混例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。*

第3章第4节，展示了如何检测Fortran编写的BLAS和LAPACK线性代数库，以及如何在C++代码中使用它们。这里，将重新讨论这个方式，但这次的角度有所不同：较少地关注检测外部库，会更深入地讨论混合C++和Fortran的方面，以及名称混乱的问题。

```shell
.
├── CMakeLists.txt
├── README.md
└── src
      ├── CMakeLists.txt
      ├── linear-algebra.cpp
      └── math
            ├── CMakeLists.txt
            ├── CxxBLAS.cpp
            ├── CxxBLAS.hpp
            ├── CxxLAPACK.cpp
            └── CxxLAPACK.hpp
```

这里，收集了BLAS和LAPACK的所有包装器，它们提供了`src/math`下的数学库了，主要程序为` linear-algebra.cpp`。因此，所有源都在`src`子目录下。我们还将CMake代码分割为三个CMakeLists.txt文件，现在来讨论这些文件。

```cmake
add_executable(linear-algebra "")

target_sources(linear-algebra
  PRIVATE
  	linear-algebra.cpp
  )

target_link_libraries(linear- algebra
  PRIVATE
  	math
  )
```

## 工作原理

使用`find_package`确定了要链接到的库。方法和之前一样，需要确保程序能够正确地调用它们定义的函数。第3章第4节中，我们面临的问题是编译器的名称符号混乱。我们使用`FortranCInterface`模块来检查所选的C和C++编译器与Fortran编译器的兼容性。我们还使用`FortranCInterface_HEADER`函数生成带有宏的头文件，以处理Fortran子例程的名称混乱。并通过以下代码实现:

```cmake
FortranCInterface_HEADER(
  fc_mangle.h
  MACRO_NAMESPACE "FC_"
  SYMBOLS DSCAL DGESV
)
```

这个命令将生成`fc_mangl.h`头文件，其中包含从Fortran编译器推断的名称混乱宏，并将其保存到当前二进制目录`CMAKE_CURRENT_BINARY_DIR`中。我们小心地将`CMAKE_CURRENT_BINARY_DIR`设置为数学目标的包含路径。生成的`fc_mangle.h`如下:

```c++
#ifndef FC_HEADER_INCLUDED
#define FC_HEADER_INCLUDED

/* Mangling for Fortran global symbols without underscores. */
#define FC_GLOBAL(name,NAME) name##_

/* Mangling for Fortran global symbols with underscores. */
#define FC_GLOBAL_(name,NAME) name##_

/* Mangling for Fortran module symbols without underscores. */
#define FC_MODULE(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name

/* Mangling for Fortran module symbols with underscores. */
#define FC_MODULE_(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name

/* Mangle some symbols automatically. */
#define DSCAL FC_GLOBAL(dscal, DSCAL)
#define DGESV FC_GLOBAL(dgesv, DGESV)
#endif
```

本例中的编译器使用下划线进行错误处理。由于Fortran不区分大小写，子例程可能以小写或大写出现，这就说明将这两种情况传递给宏的必要性。注意，CMake还将为隐藏在Fortran模块后面的符号生成宏。

**NOTE**:*现在，BLAS和LAPACK的许多实现都在Fortran子例程附带了一个C的包装层。这些包装器已经标准化，分别称为CBLAS和LAPACKE。*

由于已经将源组织成库目标和可执行目标，所以我们应该对目标的`PUBLIC`、`INTERFACE`和`PRIVATE`可见性属性的使用进行评论。与源文件一样，包括目录、编译定义和选项，当与`target_link_libraries`一起使用时，这些属性的含义是相同的:

* 使用`PRIVATE`属性，库将只链接到当前目标，而不链接到使用它的任何其他目标。
* 使用`INTERFACE`属性，库将只链接到使用当前目标作为依赖项的目标。
* 使用`PUBLIC`属性，库将被链接到当前目标，以及将其作为依赖项使用的任何其他目标。