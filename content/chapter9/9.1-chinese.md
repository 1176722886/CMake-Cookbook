# 9.1 使用C/C++库构建Fortran项目

**NOTE**:*此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-01 中找到，其中有两个示例：一个是Fortran与C的混例，另一个是Fortran和C++的混例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。*

Fortran作为高性能计算语言有着悠久的历史。目前，许多线性代数库仍然使用Fortran语言编写，许多大型的数字处理包也保持与过去几十年的代码兼容。而Fortran提出了一个很自然的语法处理数值数组，它缺乏与操作系统交互，所以为了编程的通用性，需要一个互操作性层(使用C实现)，才发布了Fortran 2003标准。本示例将展示如何用C系统库和自定义C代码来对接Fortran代码。

## 准备工作

第7章中，我们把项目结构列为一个树。每个子目录都有一个CMakeLists.txt文件，其中包含与该目录相关的指令。这使我们可以对子目录进行限制中，如这个例子：

```shell
.
├── CMakeLists.txt
└── src
      ├── bt-randomgen-example.f90
      ├── CMakeLists.txt
      ├── interfaces
      │ 		├── CMakeLists.txt
      │ 		├── interface_backtrace.f90
      │ 		├── interface_randomgen.f90
      │ 		└── randomgen.c
      └── utils
      ├── CMakeLists.txt
      └── util_strings.f90
```

我们的例子中，`src`子目录中包括`bt-randomgen-example.f90`，会将源码编译成可执行文件。另外两个子目录`interface`和`utils`包含更多的源代码，这些源代码将被编译成库。

`interfaces`子目录中的源代码展示了如何包装向后追踪的C系统库。例如，`interface_backtrace.f90 `:

```fortran
module interface_backtrace

  implicit none
  
  interface
    function backtrace(buffer, size) result(bt) bind(C, name="backtrace")
      use, intrinsic :: iso_c_binding, only: c_int, c_ptr
      type(c_ptr) :: buffer
      integer(c_int), value :: size
      integer(c_int) :: bt
    end function
    
    subroutine backtrace_symbols_fd(buffer, size, fd) bind(C, name="backtrace_symbols_fd")
      use, intrinsic :: iso_c_binding, only: c_int, c_ptr
      type(c_ptr) :: buffer
      integer(c_int), value :: size, fd
    end subroutine
  end interface
end module
```

上面的例子演示了：

* 内置`iso_c_binding`模块，确保Fortran和C类型和函数的互操作性。
* `interface`声明，将函数在单独库中绑定到相应的符号上。
* `bind(C)`属性，为声明的函数进行命名修饰。

这个子目录还包含两个源文件:

* randomgen.c：这是一个C源文件，它对外公开了一个函数，使用C标准`rand`函数在一个区间内生成随机整数。
* interface_randomgen.f90：它将C函数封装在Fortran可执行文件中使用。

回到`src/CMakeLists.txt`:

1. 使用` bt-randomgen-example.f90 `添加一个可执行目标:

   ```cmake
   add_executable(bt-randomgen-example bt-randomgen-example.f90)
   ```

2. 最后，将在子CMakeLists.txt中生成的库目标，并链接到可执行目标:

   ```cmake
   target_link_libraries(bt-randomgen-example
     PRIVATE
     	bt-randomgen-wrap
     	utils
     )
   ```

## 更多信息

`interface/CMakeLists.txt`中的CMake代码还表明，可以使用不同语言的源文件创建库。CMake能够做到以下几点:

* 列出的源文件中获取目标文件，并识别要使用哪个编译器。
* 选择适当的链接器，以便构建库(或可执行文件)。

CMake如何决定使用哪个编译器？在`project`命令时使用参数`LANGUAGES`指定，这样CMake会检查系统上给定语言编译器。当使用源文件列表添加目标时，CMake将根据文件扩展名选择适当地编译器。因此，以`.c`结尾的文件使用C编译器编译，而以`.f90`结尾的文件(如果需要预处理，可以使用`.F90`)将使用Fortran编译器编译。类似地，对于C++， `.cpp`或`.cxx`扩展将触发`C++`编译器。我们只列出了C、C++和Fortran语言的一些可能的、有效的文件扩展名，但是CMake可以识别更多的扩展名。如果您的项目中的文件扩展名，由于某种原因不在可识别的扩展名之列，该怎么办？源文件属性可以用来告诉CMake在特定的源文件上使用哪个编译器，就像这样：

```cmake
set_source_files_properties(my_source_file.axx
  PROPERTIES
  	LANGUAGE CXX
  )
```

那链接器呢？CMake如何确定目标的链接器语言？对于不混合编程语言的目标很简单：通过生成目标文件的编译器命令调用链接器即可。如果目标混合了多个语言，就像示例中一样，则根据在语言混合中，优先级最高的语言来选择链接器语言。比如，我们的示例中混合了Fortran和C，因此Fortran语言比C语言具有更高的优先级，因此使用Fortran用作链接器语言。当混合使用Fortran和C++时，后者具有更高的优先级，因此C++被用作链接器语言。就像编译器语言一样，我们可以通过目标相应的`LINKER_LANGUAGE`属性，强制CMake为我们的目标使用特定的链接器语言:

```cmake
set_target_properties(my_target
  PROPERTIES
  	LINKER_LANGUAGE Fortran
  )
```



